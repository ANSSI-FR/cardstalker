# Testing bridge's code

Bridge's source code comes with testing tools and routines.
This gives you the ability to test the modifications you make against regressions.
The tests are mainly designed to asses the conformity of the state-machine of the protocol ruling the serial link communication between the bridge and the computer.

The *tests* directory contains all the files related to the testing of bridge's code.
The tests are compiled and run on the local development machine.
It makes use of external tools to run test assertions and provide mocking of hardware related parts.


## Organization of the *tests* directory.

The root of the *tests* directory contains the headers and source files of all the test routines(*.h* and the *.c* files are located in the same directory).

A test routine is a bunch of test cases aimed to validate a particular piece of code or library.
For each test routine there are two files, respectively named :
- tests_aaa.c
- tests_aaa.h

where aaa is in name of the tested component.
The content of those files is detailed in the next sections.

The *toolbox* folder is used to put files with code that is used in several test routines.
It mainly provides functions to ease the test development.

When building and running the tests the following folders are created :
- *./obj* contains the *.o* files of the components which are about to be tested.
- *./testobj* contains the *.o* files of the test routines.
- *./out* contains the output binaries which have to be run to perform the tests.
- *./mocks/src* contains the headers and source files of the mocks generated by the *CMock* script.
- *./mocks/obj* contains the compiled objects of the mocks generated by the *CMock* script.
- *./lib* contains the compiled *.o* files of the *Unity* and *CMock* libraries. 
- *./dep* contains dependence information generated by GCC. 
- *./cov* contains the generated coverage report when *make report* is run.  


## Involved tools and libraries

To perform tests on this project we are using the *Unity* test API (https://github.com/ThrowTheSwitch/Unity).
It provides code for assertions tests.
To perform test relying on hardware implementation the mocking technique to emulate the behavior of hardware dependent functions.
For this purpose we are using the *CMock* library (https://github.com/ThrowTheSwitch/CMock).


## Procedure for adding new tests.

First create the two following files in the *tests* directory (replace aaa by a relevant name) :
- tests_aaa.c
- tests_aaa.h

The tests_aaa.c file has to include : tests_aaa.h, the *Unity* lib and the headers of the libraries being tested.
For example :
```c
#include "unity.h"

#include "state_machine.h"
#include "tests_state_machine.h"
```

If this test routine is making use of some mocked functions, it has also to include the the headers of the mocked libraries.
For example :
```c
#include "mock_reader_hal_basis.h"
#include "mock_reader_hal.h"
```

Then, you should define a main() function which initialize the *Unity* environment, run the tests defined further in the file and de-init the *Unity* environment according to the following example : 

```c
int main(int argc, char *argv[]){
	UNITY_BEGIN();
	
	RUN_TEST(test_SM_dataBlockShouldWork);
	RUN_TEST(test_SM_controlBlockShouldWork);
	RUN_TEST(test_SM_TwoReceiveInARow);
	RUN_TEST(test_SM_SendDataBlockShouldWork);
	RUN_TEST(test_SM_SendControlBlockShouldWork);
	
	return UNITY_END();
}
```

Then, you can eventually redefine the *Unity* setUp() and tearDown() functions according to the following example :

```c
void setUp(void){
	
}


void tearDown(void){
	
}
```

Finally, in this same file you define all the tests.
A test is a function which does not take arguments and does not return any values.
A test runs the functions which needs to be tested and then perform *Unity* assertions on the results.
It also eventually run the functions provided by the *CMock* framework in order to configure the mocks behaviors.
Here is an example of a typical test :

```c
void test_BUFF_Enqueue_shouldWork(void){
	BUFF_Buffer buffer;
	BUFF_Status retVal;
	uint8_t byte1 = 0xFE;
	uint8_t byte2 = 0xFD;
	
	
	if(BUFF_MAX_SIZE < 2){
		TEST_IGNORE();
	}
	
	retVal = BUFF_Init(&buffer);
	TEST_ASSERT_TRUE(retVal == BUFF_OK);
	
	retVal = BUFF_Enqueue(&buffer, byte1);
	TEST_ASSERT_TRUE(retVal == BUFF_OK);	
	TEST_ASSERT_EQUAL_UINT8(byte1, buffer.array[0]);
	
	retVal = BUFF_Enqueue(&buffer, byte2);
	TEST_ASSERT_TRUE(retVal == BUFF_OK);	
	TEST_ASSERT_EQUAL_UINT8(byte2, buffer.array[1]);
}
```

The tests_aaa.h file contains the prototypes of all the tests defined in the tests_aaa.c file.


Once the tests_aaa.h and tests_aaa.c files are ready, the following lines needs to be added to the *Makefile_tests* :

``` shell
$(DIR_OUT)/tests_aaa.elf:$(DIR_TEST_OBJ)/tests_aaa.o $(DIR_LIB)/$(UNITY_OBJ) $(DIR_OBJ)/aaa.o
	$(LD) $(CFLAGS) $(LDFLAGS) $^ -o $@
```

Where *$(DIR_OBJ)/aaa.o* is the component currently being tested.
If the tests of this component needs to be linked with other components, add them right after the current dependencies.
For example :

``` shell
$(DIR_OUT)/tests_aaa.elf:$(DIR_TEST_OBJ)/tests_aaa.o $(DIR_LIB)/$(UNITY_OBJ) $(DIR_OBJ)/aaa.o $(DIR_OBJ)/bbb.o $(DIR_OBJ)/ccc.o
	$(LD) $(CFLAGS) $(LDFLAGS) $^ -o $@
```

If mocks are involved, the following lines needs to be added :

``` shell
$(DIR_OUT)/tests_aaa.elf:$(MOCKS_OBJS) $(DIR_TEST_OBJ)/$(TESTS_TOOLBOX_OBJ) $(DIR_LIB)/$(UNITY_OBJ) $(DIR_LIB)/$(CMOCK_OBJ) $(DIR_TEST_OBJ)/tests_aaa.o $(DIR_OBJ)/aaa.o $(DIR_OBJ)/bbb.o $(DIR_OBJ)/ccc.o
	$(LD) $(CFLAGS) $(LDFLAGS) $^ -o $@
```

- The *$(DIR_LIB)/$(CMOCK_OBJ)* dependency enables linking the the *CMock* library.
- The *$(MOCKS_OBJS)* dependency enables linking with the mocks.


## Instructions for building and running tests and reports.

In the root directory, to build the tests and run them :

``` shell
$ make tests
$ make test
```
To build the code coverage report :

``` shell
$ make report
```

Then you can open with your browser the file :
``` shell
tests/cov/cov_report/index.html
```

## Makefile configuration.

The instructions for building the tests are written in the *Makefile_tests* file in the root directory of the project.
This Makefile is aimed to be run the main Makefile.

The *Makefile_tests* defines a *HEADERS_TO_MOCK* variable.
It contains the list of all the headers that have to be mocked when building the tests.

The *EXCLUDED_FROM_COMPILATION* variable contains the list of all the files that should not be compiled when building the tests.
It automatically includes the files which are going to be mocked.
It also typically adds the purely hardware code which can not be compiled on the local computer.
For example *startup_stm32f407xx.s*.
